1.事务四大特性？

保证事务的完整性和一致性。

ACID：
* 原子性(不可分割)
* 一致性(事务开始和事务结束以后，数据库的完整性约束没有被破坏)
* 隔离性(多个事务并发访问，事务之间是隔离的)
* 持久性(持久化保存在数据库中)

RDBMS 采用日志来保证事务的原子性、一致性和持久性。采用锁机制来实现事务的隔离性。

http://blog.csdn.net/shuaihj/article/details/14163713

2.数据库的隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？

* 未提交读：引发 脏读 问题
* 已提交读：引发 不可重复读 问题
* 可重复读：引发 幻读 问题
* 可串行读：读加共享锁，写加排他锁。一个个执行事务(级别最高)，性能差

MySQL 默认为可重复读。

https://www.cnblogs.com/fjdingsd/p/5273008.html

3.MySQL的两种存储引擎区别，各自适用场景？

* MyISAM：不支持事务处理，不支持行级锁，不支持外键，主要用于高负载的 select，插入和查询，256TB，访问速度快
* InnoDB：支持事务处理，使用行级锁，支持外键，写的处理效率会差些，不支持全文索引，64TB
* Memory：内存中，用于内容变化不频繁的表
* BlackHole：主要用于日志记录或同步归档

场景：
* MyISAM 管理非事务表，提供高速存储和检索，以及全文搜索能力，用于执行大量 SELECT 查询。
* InnoDB 管理事务表，执行大量 INSERT 和 UPDATE 操作，提高多用户并发操作。

http://blog.csdn.net/qh_java/article/details/14045827

4.数据库的优化？

* SQL语句及索引优化
* 数据库表结构
* 系统配置
* 硬件

如：应该尽量把字段设置为 NOT NULL；应考虑在 where 及 order by 涉及的列上建立索引。

http://www.cnblogs.com/yunfeifei/p/3850440.html

5.索引有 B+ 索引和 hash 索引，各自的区别？

查询效率

* B+ 索引：需要从根节点到中间节点，最后才能访问到叶节点，多次 IO 访问
* Hash 索引：在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

数据库索引是存储在磁盘上，为了减少磁盘 IO 访问次数，那么索引树的高度要小。

6.B+ 索引数据结构，和 B 树的区别？

* B 树：m 阶多路平衡树，每个叶子节点最多包含 m-1 个元素，应用文件系统以及部分数据库索引(MongoDB)

根节点至少两个子女，每个中间节点都包含 k-1 个元素和 k 个孩子，每个叶子节点最多包含 k-1 个元素，所有叶子节点都位于同一层。(m/2 <= k <=m)

每个元素都是从小到大排列。

B 树只要找到匹配元素即可，查找不稳定。

* B+ 树：k 个子树的中间节点包含 k 个元素，每个元素不保存数据，用来索引，所有数据保存在叶子节点上。叶子节点从小到大顺序链接。

B+ 树必须查找到叶子节点，稳定。

B+ 树查询性能稳定，IO 次数更少，范围查询简便。

http://blog.csdn.net/wl044090432/article/details/53423333

7.索引的分类,那些情况下索引会失效？

索引被创建于已有的表中，它可使对行的定位更快速更有效。

* 主键索引：特殊的唯一索引，不允许有空值。
* 唯一索引：索引列的值必须唯一，两个行不能拥有相同的索引值。
* 普通索引：最基本的索引，没有任何限制
* 全文索引：针对较大的数据，生成全文索引很耗时，耗空间。
* 组合索引：遵循"最左前缀"原则，将多个索引值拼接成一个字符串

以下情况下索引会失效：

* 条件中有 or，将 or 条件中的每个列都加上索引
* LIKE 查询是以 % 开头
* 如何列类型是字符串，那一定要在条件中将数据使用引号引用起来
* 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

查看 city 表是否有索引：`SHOW INDEX FROM city;`

用 CREATE INDEX 或 ALTER TABLE 来给表增加索引。

删除索引可以利用 ALTER TABLE 或 DROP INDEX 语句来实现。

```sql
ALTER TABLE staff ADD INDEX(active);   // 在 staff 表中，对 active 列建立普通索引
ALTER TABLE staff ADD UNIQUE(email);   // 在 staff 表中，对 email 列建立唯一索引
ALTER TABLE staff ADD PRIMARY KEY(staff_id); // 在 staff 表中，对 staff_id 列建立主键索引
```

```sql
// 使用 CREATE INDEX 语句对表增加普通索引和唯一索引
// 不能用 CREATE INDEX 语句创建 PRIMARY KEY 索引

CREATE INDEX first ON staff(first_name); // 在 staff 表中，对 first_name 列建立普通索引，索引名为 first
CREATE UNIQUE INDEX emails ON staff(email); // 在 staff 表中，对 email 列建立唯一索引，索引名为 emails
```

```sql
DROP INDEX emails on staff; // 在 staff 表中，删除索引 emails
ALTER TABLE staff DROP INDEX active; // 在 staff 表中，删除索引 active
ALTER TABLE staff DROP PRIMARY KEY;  // 删除主键索引
```

8.有哪些锁，SELECT 时怎么加排它锁？

行级锁和表级锁、页及锁

行级锁包括共享锁和排它锁。

* 加排它锁可以使用 SELECT ...FOR UPDATE 语句
* 加共享锁可以使用 SELECT ... lock in share mode 语句

9.内连接、外连接、交叉连接和笛卡儿积？

INNER JOIN

OUTER JOIN

CROSS JOIN：没有 WHERE 子句，它返回连接表中所有数据行的笛卡尔积 

10.long_query 怎么解决？

MySQL慢查询就是在日志中记录运行比较慢的 SQL 语句，这个功能需要开启才能用。

添加索引

11.varchar 和 char 的区别，适用场景？

* char：容纳固定长度的字符串，方便程序的存储与查找，付出的是空间的代价

* varchar：容纳可变长度的字符串

12.mysql 并发情况下怎么解决？

事务，加锁

缓存

加锁：悲观锁(共享锁和排它锁)和乐观锁

比如缓存、利用主从库实现读写分离、分表、使用队列写入等方法来降低并发读写。

13.Redis 的数据结构有哪些？

* String——字符串
* Hash——字典
* List——列表
* Set——集合
* Sorted Set——有序集合

14.Redis 队列的应用场景？

* 最新消息排行等功能
* 消息队列

订阅-发布系统的使用场景：用作实时消息系统，比如普通的即时聊天，群聊等功能。

15.Redis 和 MongoDB 区别？

* Redis：内存存储，适用较小数据量的性能和运算，支持事务
* MongoDB：文档型存储，适用海量数据，集群部署

16.数据库的主从复制？

* 实时灾备，用于故障切换
* 读写分离，提供查询服务
* 备份，避免影响业务

从库生成两个线程，一个 I/O 线程，一个 SQL 线程；

https://www.cnblogs.com/Aiapple/p/5792939.html

17.关系型数据库和非关系型数据库的区别？

关系：复杂查询

非关系：key-value，性能和扩展性

18.聚集索引和非聚集索引区别？

* 聚集索引：叶子节点直接包含卫星数据
* 非聚集索引：叶子节点带有指向卫星数据的指针

19.数据库的三范式？

* 第一范式(确保每列保持原子性)
* 第二范式(确保表中的每列都和主键相关)  完全依赖
* 第三范式(确保每列都和主键列直接相关,而不是间接相关)  消除传递依赖 

20.MVCC机制，根据具体场景，说明版本控制机制？

MVCC 是一种多版本并发控制机制。

MVCC 是通过保存数据在某个时间点的快照来实现的。

21.幻读和不可重复读的区别？

* 不可重复读：一个事务中前后两次读取的结果并不一致。在于修改。
* 幻读：在于新增和删除，同样的条件，第1次和第2次读的记录数不一样。

http://blog.csdn.net/yuxin6866/article/details/52649048

22.悲观锁和乐观锁，区别？

悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

乐观锁：适用写少，读多，可以省去了锁的开销，加大了系统的整个吞吐量。

悲观锁：冲突很多的情况。

23.数据库索引的优缺点？

优点：提高数据检索的性能。

缺点：
* 索引会占据物理存储空间
* 当向表中插入/删除数据时，索引也需要动态更新，降低了插入/删除的速度
